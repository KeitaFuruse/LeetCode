
最大部分配列問題をO(n)で解くにはKadane's Algorithmを使う。
Brute Force法でも解けるがO(n^2)になる

配列 arr = [-2, 3, 2, -1]　があったとする。

一時的合計 = グローバル合計 = arr[0]
とすると、この時arr[0] は-2で、この時の一時的な最大合計は-2、グローバルな最大合計も-2である。

arr[1]ではどうだろうか。
一時合計（-2）とarr[1]を足した値か、arr[1]ではarr[1](=3)の方が大きい。
一時合計というのはそれまでの配列の組み合わせのなかで最も大きい値であるので、arr[i]>一時合計+arr[i]であるとそうれば一時合計の値は更新される。
これで一時合計をarr[1]にアップデートする。

なぜglobalの方はこの時点でアップデートしないのか。
→それはarr[i]と一時合計+arr[i]の合計を比べているから
では、arr[i],一時合計+arr[i]、一時合計の３つで比べれば解決するのか？
→しない。なぜなら、そうしてしまうと「隣り合った配列（contiguas）」という条件を無視して配列の中のi>0の合計となってしまう。







